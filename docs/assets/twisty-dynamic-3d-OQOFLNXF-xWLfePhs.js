var Gt=Object.defineProperty;var zt=(e,t,i)=>t in e?Gt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i;var c=(e,t,i)=>(zt(e,typeof t!="symbol"?t+"":t,i),i),ht=(e,t,i)=>{if(!t.has(e))throw TypeError("Cannot "+i)};var q=(e,t,i)=>(ht(e,t,"read from private field"),i?i.call(e):t.get(e)),W=(e,t,i)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,i)},_=(e,t,i,s)=>(ht(e,t,"write to private field"),s?s.call(e,i):t.set(e,i),i);var V=(e,t,i)=>(ht(e,t,"access private method"),i);import{T as Bt,d as x,C as N,B as Z,V as R,E as H,f as U,g as Q,O as Dt,h as Lt,i as Ot,G as Rt,j as tt,D as bt,k as wt,l as kt,m as $,F as nt,o as Pt,q as It,s as Nt,t as Ht,u as et,M as jt}from"./index-5PRf6e5S.js";import{v as Ee}from"./index-5PRf6e5S.js";function Ft(e){return e*e*e*(10-e*(15-6*e))}var vt=new Bt,qt=new x({color:new N(6710886).convertLinearToSRGB()}),Wt=new x({color:new N(13421772).convertLinearToSRGB(),side:Z,transparent:!0,opacity:.75}),ot=new x({visible:!1}),_t=new x({color:4513228}),Vt=new x({color:16776618}),Jt=new x({color:4513228,side:Z,transparent:!0,opacity:.5}),Qt=new x({color:16775545,side:Z,transparent:!0,opacity:.5}),J=class{constructor(e,t,i,s,r,n){c(this,"stickerMaterial");c(this,"hintStickerMaterial");this.vector=e,this.fromZ=t,this.color=i,this.dimColor=s,this.hintOpacityScale=r;const o=new N(i).convertLinearToSRGB(),a=new N(s).convertLinearToSRGB();this.stickerMaterial={regular:new x({color:o,side:nt}),dim:new x({color:a,side:nt}),oriented:_t,experimentalOriented2:Vt,ignored:qt,invisible:ot},this.hintStickerMaterial={regular:new x({color:new N((n==null?void 0:n.hintColor)??i).convertLinearToSRGB(),side:Z,transparent:!0,opacity:.5*r}),dim:new x({color:new N((n==null?void 0:n.hintDimColor)??s).convertLinearToSRGB(),side:Z,transparent:!0,opacity:.5*r}),oriented:Jt,experimentalOriented2:Qt,ignored:Wt,invisible:ot}}},z=[new J(new R(0,1,0),new H(-U/4,0,0),16777215,14540253,1.25),new J(new R(-1,0,0),new H(0,-U/4,0),16750848,8934656,1,{hintDimColor:8930304}),new J(new R(0,0,1),new H(0,0,0),65280,34816,1,{hintDimColor:39168}),new J(new R(1,0,0),new H(0,U/4,0),16711680,6684672,1,{hintDimColor:6684672}),new J(new R(0,0,-1),new H(0,U/2,0),2254591,1127304,.75,{hintDimColor:6246}),new J(new R(0,-1,0),new H(U/4,0,0),16776960,8947712,1.25,{hintDimColor:14540032})],m={U:0,L:1,F:2,R:3,B:4,D:5},Xt={U:m.U,u:m.U,Uw:m.U,Uv:m.U,y:m.U,L:m.L,l:m.L,Lw:m.L,Lv:m.L,M:m.L,F:m.F,f:m.F,Fw:m.F,Fv:m.F,S:m.F,z:m.F,R:m.R,r:m.R,Rw:m.R,Rv:m.R,x:m.R,B:m.B,b:m.B,Bw:m.B,Bv:m.B,D:m.D,d:m.D,Dw:m.D,Dv:m.D,E:m.D},j={stickerElevation:.503,foundationWidth:1,hintStickerElevation:1.45},Zt=2,$t={showMainStickers:!0,hintFacelets:"floating",showFoundation:!0,experimentalStickeringMask:void 0,foundationSprite:null,hintSprite:null,initialHintFaceletsAnimation:"auto",faceletScale:"auto"},Kt=.85;function ut(e){return typeof e.faceletScale>"u"||e.faceletScale==="auto"?Kt:e.faceletScale}var Yt=new x({color:0,opacity:1,transparent:!0}),te=new x({color:0,opacity:.3,transparent:!0}),M=class{constructor(e,t,i){c(this,"matrix");c(this,"stickerFaces");this.orbit=e;const s=typeof t=="string"?t.split(""):t;this.stickerFaces=s.map(r=>m[r]),this.matrix=new Q,this.matrix.setPosition(st[e]),this.matrix.premultiply(new Q().makeRotationFromQuaternion(i))}};function h(e,t){return new Nt().setFromAxisAngle(e,U*t/4)}var u={O:new R(0,0,0),U:new R(0,-1,0),L:new R(1,0,0),F:new R(0,0,-1),R:new R(-1,0,0),B:new R(0,0,1),D:new R(0,1,0)},st={EDGES:new R(0,1,1),CORNERS:new R(1,1,1),CENTERS:new R(0,1,0)},ee={EDGES:[0,1].map(e=>new Q().makeRotationAxis(st.EDGES.clone().normalize(),-e*U/2)),CORNERS:[0,1,2].map(e=>new Q().makeRotationAxis(st.CORNERS.clone().normalize(),-e*U/3)),CENTERS:[0,1,2,3].map(e=>new Q().makeRotationAxis(st.CENTERS.clone().normalize(),-e*U/4))},ft=[m.U,m.F,m.R],K={EDGES:[new M("EDGES","UF",h(u.O,0)),new M("EDGES","UR",h(u.U,3)),new M("EDGES","UB",h(u.U,2)),new M("EDGES","UL",h(u.U,1)),new M("EDGES","DF",h(u.F,2)),new M("EDGES","DR",h(u.F,2).premultiply(h(u.D,1))),new M("EDGES","DB",h(u.F,2).premultiply(h(u.D,2))),new M("EDGES","DL",h(u.F,2).premultiply(h(u.D,3))),new M("EDGES","FR",h(u.U,3).premultiply(h(u.R,3))),new M("EDGES","FL",h(u.U,1).premultiply(h(u.R,3))),new M("EDGES","BR",h(u.U,3).premultiply(h(u.R,1))),new M("EDGES","BL",h(u.U,1).premultiply(h(u.R,1)))],CORNERS:[new M("CORNERS","UFR",h(u.O,0)),new M("CORNERS","URB",h(u.U,3)),new M("CORNERS","UBL",h(u.U,2)),new M("CORNERS","ULF",h(u.U,1)),new M("CORNERS","DRF",h(u.F,2).premultiply(h(u.D,1))),new M("CORNERS","DFL",h(u.F,2).premultiply(h(u.D,0))),new M("CORNERS","DLB",h(u.F,2).premultiply(h(u.D,3))),new M("CORNERS","DBR",h(u.F,2).premultiply(h(u.D,2)))],CENTERS:[new M("CENTERS","U",h(u.O,0)),new M("CENTERS","L",h(u.R,3).premultiply(h(u.U,1))),new M("CENTERS","F",h(u.R,3)),new M("CENTERS","R",h(u.R,3).premultiply(h(u.D,1))),new M("CENTERS","B",h(u.R,3).premultiply(h(u.D,2))),new M("CENTERS","D",h(u.R,2))]},dt=1/3,it={EDGES:[[[0,4,6],[0,4,5]],[[3,5,7],[0,7,5]],[[2,4,8],[0,10,5]],[[1,3,7],[0,1,5]],[[2,4,2],[2,4,3]],[[3,5,1],[2,7,3]],[[0,4,0],[2,10,3]],[[1,3,1],[2,1,3]],[[3,5,4],[3,6,4]],[[1,3,4],[1,2,4]],[[1,9,4],[1,8,4]],[[3,11,4],[3,0,4]]],CORNERS:[[[0,5,6],[0,5,5],[0,6,5]],[[3,5,8],[0,8,5],[0,9,5]],[[2,3,8],[0,11,5],[0,0,5]],[[1,3,6],[0,2,5],[0,3,5]],[[3,5,2],[2,6,3],[2,5,3]],[[2,3,2],[2,3,3],[2,2,3]],[[1,3,0],[2,0,3],[2,11,3]],[[0,5,0],[2,9,3],[2,8,3]]],CENTERS:[[[0,4,7]],[[0,1,4]],[[0,4,4]],[[0,7,4]],[[0,10,4]],[[0,4,1]]]},yt=null;function ie(){return yt??(yt=new Ht(j.foundationWidth,j.foundationWidth,j.foundationWidth))}function mt(){const e=new kt,t=.5;return e.setAttribute("position",new $(new Float32Array([t,t,0,-t,t,0,t,-t,0,-t,t,0,-t,-t,0,t,-t,0]),3)),e.setAttribute("uv",new $(new Float32Array([1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,1,1]),2)),e}var gt=null;function se(){return gt??(gt=mt())}var at,X,rt,ct,Ct,Et,re=(Et=class extends Dt{constructor(t,i,s={}){super();W(this,X);W(this,ct);c(this,"kpuzzleFaceletInfo");c(this,"pieces",{});c(this,"options");c(this,"experimentalHintStickerMeshes",[]);c(this,"experimentalFoundationMeshes",[]);c(this,"setSpriteURL");c(this,"sprite",new Promise(t=>{this.setSpriteURL=i=>{vt.load(i,t)}}));c(this,"setHintSpriteURL");c(this,"hintSprite",new Promise(t=>{this.setHintSpriteURL=i=>{vt.load(i,t)}}));W(this,at,null);if(this.kpuzzle=t,this.scheduleRenderCallback=i,this.options={...$t},Object.assign(this.options,s),this.kpuzzle.name()!=="3x3x3")throw new Error(`Invalid puzzle for this Cube3D implementation: ${this.kpuzzle.name()}`);s.foundationSprite&&this.setSprite(s.foundationSprite),s.hintSprite&&this.setHintSprite(s.hintSprite),this.kpuzzleFaceletInfo={};for(const r in K){const n=[];this.kpuzzleFaceletInfo[r]=n,this.pieces[r]=K[r].map(this.createCubie.bind(this,r,n))}this.scale.set(dt,dt,dt),this.options.experimentalStickeringMask&&this.setStickeringMask(this.options.experimentalStickeringMask),V(this,ct,Ct).call(this),this.options.faceletScale&&this.experimentalSetFaceletScale(this.options.faceletScale)}setSprite(t){this.sprite=t}setHintSprite(t){this.hintSprite=t}experimentalSetStickerSpriteURL(t){this.setSpriteURL(t)}experimentalSetHintStickerSpriteURL(t){this.setHintSpriteURL(t)}setStickeringMask(t){if(t.specialBehaviour==="picture"){for(const i of Object.values(this.kpuzzleFaceletInfo))for(const s of i)for(const r of s){r.facelet.material=ot;const{hintFacelet:n}=r;n&&(n.material=ot)}return}this.options.experimentalStickeringMask=t;for(const[i,s]of Object.entries(t.orbits))for(let r=0;r<s.pieces.length;r++){const n=s.pieces[r];if(n){const o=this.kpuzzleFaceletInfo[i][r];for(let a=0;a<o.length;a++){const l=n.facelets[a];if(l){const f=o[a],k=typeof l=="string"?l:l==null?void 0:l.mask;f.facelet.material=z[f.faceIdx].stickerMaterial[k];const E=typeof l=="string"?k:l.hintMask??k;f.hintFacelet&&(f.hintFacelet.material=z[f.faceIdx].hintStickerMaterial[E])}}}}this.scheduleRenderCallback&&this.scheduleRenderCallback()}experimentalUpdateOptions(t){if("showMainStickers"in t)throw new Error("Unimplemented");const i=t.showFoundation;if(typeof i<"u"&&this.options.showFoundation!==i){this.options.showFoundation=i;for(const o of this.experimentalFoundationMeshes)o.visible=i}const s=t.hintFacelets;if(typeof s<"u"&&this.options.hintFacelets!==s&&Ot[s]){this.options.hintFacelets=s;for(const o of this.experimentalHintStickerMeshes)o.visible=s==="floating";this.scheduleRenderCallback()}const{experimentalStickeringMask:r}=t;typeof r<"u"&&(this.options.experimentalStickeringMask=r,this.setStickeringMask(r),this.scheduleRenderCallback());const{faceletScale:n}=t;typeof n<"u"&&this.experimentalSetFaceletScale(n)}onPositionChange(t){const i=t.pattern;for(const s in K){const r=K[s];for(let n=0;n<r.length;n++){const o=i.patternData[s].pieces[n];this.pieces[s][o].matrix.copy(K[s][n].matrix),this.pieces[s][o].matrix.multiply(ee[s][i.patternData[s].orientation[n]])}for(const n of t.movesInProgress){const o=n.move,a=z[Xt[o.family]].vector,l=new Q().makeRotationAxis(a,-this.ease(n.fraction)*n.direction*o.amount*U/4);for(let f=0;f<r.length;f++){const k=this.kpuzzle.moveToTransformation(o.modified({amount:1})),E=k.transformationData[s].permutation[f];if(f!==E||k.transformationData[s].orientationDelta[f]!==0){const v=i.patternData[s].pieces[f];this.pieces[s][v].matrix.premultiply(l)}}}}this.scheduleRenderCallback()}createCubie(t,i,s,r){var a;const n=[];i.push(n);const o=new Rt;if(this.options.showFoundation){const l=this.createCubieFoundation();o.add(l),this.experimentalFoundationMeshes.push(l)}for(let l=0;l<s.stickerFaces.length;l++){const f=this.createSticker(z[ft[l]],z[s.stickerFaces[l]],!1),k={faceIdx:s.stickerFaces[l],facelet:f};if(o.add(f),this.options.hintFacelets==="floating"){const E=this.createSticker(z[ft[l]],z[s.stickerFaces[l]],!0);o.add(E),k.hintFacelet=E,this.experimentalHintStickerMeshes.push(E)}if(((a=this.options.experimentalStickeringMask)==null?void 0:a.specialBehaviour)==="picture"&&it[t]&&it[t][r]&&it[t][r][l]){const[E,v,g]=it[t][r][l];(async()=>{const p=async C=>{const b=await(C?this.hintSprite:this.sprite),T=this.createSticker(z[ft[l]],z[s.stickerFaces[l]],C);T.material=new x({map:b,side:C?Z:bt,transparent:!0});const G=v/12,L=(v+1)/12,F=g/9,O=(g+1)/9;let D=new et(G,F),y=new et(G,O),d=new et(L,O),S=new et(L,F);switch(E){case 1:{[D,y,d,S]=[y,d,S,D];break}case 2:{[D,y,d,S]=[d,S,D,y];break}case 3:{[D,y,d,S]=[S,D,y,d];break}}T.geometry.setAttribute("uv",new $(new Float32Array([d.x,d.y,y.x,y.y,S.x,S.y,y.x,y.y,D.x,D.y,S.x,S.y]),2)),o.add(T)};p(!0),p(!1)})()}n.push(k)}return o.matrix.copy(s.matrix),o.matrixAutoUpdate=!1,this.add(o),o}createCubieFoundation(){var i;const t=ie();return new tt(t,((i=this.options.experimentalStickeringMask)==null?void 0:i.specialBehaviour)==="picture"?Yt:te)}createSticker(t,i,s){var o,a;const r=((o=this.options.experimentalStickeringMask)==null?void 0:o.specialBehaviour)==="picture"?mt():s?V(this,X,rt).call(this):se(),n=new tt(r,s?i.hintStickerMaterial.regular:i.stickerMaterial.regular);return n.setRotationFromEuler(t.fromZ),n.position.copy(t.vector),n.position.multiplyScalar(s?((a=this.options.experimentalStickeringMask)==null?void 0:a.specialBehaviour)==="picture"?Zt:j.hintStickerElevation:j.stickerElevation),n.scale.setScalar(ut(this.options)),n}experimentalSetFoundationOpacity(t){this.experimentalFoundationMeshes[0].material.opacity=t}experimentalSetFaceletScale(t){var i;this.options.faceletScale=t;for(const s of Object.values(this.kpuzzleFaceletInfo))for(const r of s)for(const n of r)n.facelet.scale.setScalar(ut(this.options)),(i=n.hintFacelet)==null||i.scale.setScalar(ut(this.options))}ease(t){return Ft(t)}},at=new WeakMap,X=new WeakSet,rt=function(){return q(this,at)??_(this,at,mt())},ct=new WeakSet,Ct=function(){if(this.options.initialHintFaceletsAnimation==="none"||this.options.initialHintFaceletsAnimation!=="always"&&Lt())return;const t=j.hintStickerElevation-j.stickerElevation;V(this,X,rt).call(this).translate(0,0,-t),setTimeout(()=>{const i=performance.now();let s=0;const r=1e3;function n(a){return a*(2-a)}const o=()=>{var f;const a=performance.now()-i,l=n(a/r)*t;V(this,X,rt).call(this).translate(0,0,l-s),s=l,a<r&&(requestAnimationFrame(o),(f=this.scheduleRenderCallback)==null||f.call(this))};o()},500)},Et),Mt=new x({side:bt,color:0}),I=new x({visible:!1}),Y=new x({vertexColors:!0});function pt(e,t,i){return Math.hypot(e[3*t]-e[3*i],e[3*t+1]-e[3*i+1],e[3*t+2]-e[3*i+2])}function ne(e,t,i,s){const r=pt(e,t,i),n=pt(e,i,s),o=pt(e,t,s),a=(r+n+o)/2;return Math.sqrt(a*(a-r)*(a-n)*(a-o))}function oe(e){let t=0;for(let i=2;3*i<e.length;i++)t+=ne(e,0,1,i);return t}function ae(e){const t=Math.hypot(e[0],e[1],e[2]);return e[0]/=t,e[1]/=t,e[2]/=t,e}function ce(e,t){const i=new Array(3);return i[0]=e[1]*t[2]-e[2]*t[1],i[1]=e[2]*t[0]-e[0]*t[2],i[2]=e[0]*t[1]-e[1]*t[0],i}function le(e){const t=[e[3]-e[0],e[4]-e[1],e[5]-e[2]],i=[e[6]-e[3],e[7]-e[4],e[8]-e[5]],s=ce(t,i);return ae(s)}function he(e,t){const i=[],s=new Array(3),r=new Array(3);for(let n=1;n<10;n++){for(let a=0;a<e.length;a+=3){const l=(a+e.length-3)%e.length,f=(a+3)%e.length;for(let p=0;p<3;p++)s[p]=e[l+p]-e[a+p],r[p]=e[f+p]-e[a+p];const k=Math.hypot(s[0],s[1],s[2]),E=Math.hypot(r[0],r[1],r[2]);for(let p=0;p<3;p++)s[p]/=k,r[p]/=E;const v=s[0]*r[0]+s[1]*r[1]+s[2]*r[2],g=t/Math.sqrt(1-v*v);for(let p=0;p<3;p++)i[a+p]=e[a+p]+(s[p]+r[p])*g}let o=!0;for(let a=0;o&&a<i.length;a+=3){const l=(a+3)%e.length;let f=0;for(let k=0;k<3;k++){const E=e[l+k]-e[a+k],v=i[l+k]-i[a+k];f+=E*v}f<=0&&(o=!1)}if(o)return i;t/=2}return e}var Tt=class{constructor(e,t){c(this,"pos");c(this,"ipos");c(this,"vertices");c(this,"colors");c(this,"uvs");c(this,"ind");this.sz=e,this.tm=t,this.vertices=new Float32Array(9*e),this.uvs=void 0,this.colors=new Uint8Array(18*e),this.ind=new Uint8Array(e),this.pos=0,this.ipos=0}add(e,t,i){this.vertices[this.pos]=e[3*t+0],this.vertices[this.pos+1]=e[3*t+1],this.vertices[this.pos+2]=e[3*t+2],this.colors[this.pos]=i>>16,this.colors[this.pos+1]=i>>8&255,this.colors[this.pos+2]=i&255,this.pos+=3}addUncolored(e,t){this.vertices[this.pos]=e[3*t+0],this.vertices[this.pos+1]=e[3*t+1],this.vertices[this.pos+2]=e[3*t+2],this.pos+=3}setind(e){this.ind[this.ipos++]=e}makePoly(e,t,i){const s=e;for(let r=1;3*(r+1)<s.length;r++)this.add(s,0,t),this.add(s,r,t),this.add(s,r+1,t),this.setind(i)}setAttributes(e){e.setAttribute("position",new $(this.vertices,3));const t=this.colors.subarray(0,9*this.sz);e.setAttribute("color",new $(t,3,!0))}makeGroups(e){e.clearGroups();for(let t=0;t<this.ipos;){const i=t++,s=this.ind[i];for(;this.ind[t]===s;)t++;e.addGroup(3*i,3*(t-i),s)}}saveOriginalColors(){this.colors.copyWithin(this.pos,0,this.pos)}},ue=class{constructor(e,t,i,s){c(this,"origColor");c(this,"origColorStickeringMask");c(this,"faceColor");c(this,"texturePtr");c(this,"twistVal",-1);c(this,"stickerStart");c(this,"stickerEnd");c(this,"hintStart");c(this,"hintEnd");c(this,"foundationStart");c(this,"foundationEnd");c(this,"isDup");c(this,"faceNum");this.isDup=!!t.isDup,this.faceNum=t.face,this.stickerStart=e.ipos;const r=new N(t.color).getHex();this.origColor=r,this.origColorStickeringMask=r,s!=null&&s.stickeringMask&&this.setStickeringMask(e,s.stickeringMask),this.faceColor=r;const n=this.stickerCoords(t.coords,i);e.makePoly(n,this.faceColor,this.isDup?4:0),this.stickerEnd=e.ipos}stickerCoords(e,t){return he(e.slice(),t)}hintCoords(e,t,i,s){e=this.stickerCoords(e,i),s=s.slice();for(let n=0;n<3;n++)s[n]*=.5*t;const r=new Array(e.length);for(let n=0;3*n<e.length;n++){const o=e.length/3-1-n;r[3*n]=e[3*o]+s[0],r[3*n+1]=e[3*o+1]+s[1],r[3*n+2]=e[3*o+2]+s[2]}return r}foundationCoords(e){const t=e.slice();for(let i=0;i<e.length;i++)t[i]=e[i]*.999;return t}addHint(e,t,i,s,r,n){this.hintStart=e.ipos;const o=this.hintCoords(t.coords,s,r,n);e.makePoly(o,this.faceColor,i&&!this.isDup?2:4),this.hintEnd=e.ipos}addFoundation(e,t,i){this.foundationStart=e.ipos;const s=this.foundationCoords(t.coords);e.makePoly(s,i,this.isDup?4:6),this.foundationEnd=e.ipos}setHintStickers(e,t){const i=this.isDup||!t?4:2;for(let s=this.hintStart;s<this.hintEnd;s++)e.ind[s]=i|e.ind[s]&1}setStickeringMask(e,t){let i=0;switch(t){case"regular":{i=this.origColor;break}case"dim":{this.origColor===16777215?i=14540253:i=new N(this.origColor).multiplyScalar(.5).getHex();break}case"oriented":{i=16746751;break}case"ignored":{i=4473924;break}case"invisible":i=this.origColor}this.origColorStickeringMask=i;for(let s=9*this.stickerStart;s<9*this.stickerEnd;s+=3)e.colors[e.pos+s]=i>>16,e.colors[e.pos+s+1]=i>>8&255,e.colors[e.pos+s+2]=i&255;for(let s=9*this.hintStart;s<9*this.hintEnd;s+=3)e.colors[e.pos+s]=i>>16,e.colors[e.pos+s+1]=i>>8&255,e.colors[e.pos+s+2]=i&255;this.setHintStickers(e,t!=="invisible"&&!this.isDup)}addUVs(e){const t=e.uvs,i=e.vertices,s=new Array(3);for(let r=3*this.stickerStart;r<3*this.stickerEnd;r++){s[0]=i[3*r],s[1]=i[3*r+1],s[2]=i[3*r+2];const n=e.tm.getuv(this.faceNum,s);t[2*r]=n[0],t[2*r+1]=n[1]}for(let r=3*this.hintStart;r<3*this.hintEnd;r++){s[0]=i[3*r],s[1]=i[3*r+1],s[2]=i[3*r+2];const n=e.tm.getuv(this.faceNum,s);t[2*r]=n[0],t[2*r+1]=n[1]}}setTexture(e,t){if(this.texturePtr===t)return 0;this.texturePtr=t;const i=6*e.sz;return e.uvs.copyWithin(6*this.stickerStart,6*t.stickerStart+i,6*t.stickerEnd+i),e.uvs.copyWithin(6*this.hintStart,6*t.hintStart+i,6*t.hintEnd+i),1}setColor(e,t){const i=t.origColorStickeringMask;if(this.faceColor!==i){this.faceColor=i;const s=e.pos;return e.colors.copyWithin(9*this.stickerStart,9*t.stickerStart+s,9*t.stickerEnd+s),e.colors.copyWithin(9*this.hintStart,9*t.hintStart+s,9*t.hintEnd+s),1}else return 0}},fe=class{constructor(e,t,i){c(this,"cubie");c(this,"geo");this.cubie=new Rt;const s=e.coords,r=new Tt(s.length/3-2,t);for(let o=1;3*o+3<s.length;o++)r.addUncolored(s,0),r.addUncolored(s,o),r.addUncolored(s,o+1);this.geo=new kt,r.setAttributes(this.geo);const n=new tt(this.geo,I);n.userData.quantumMove=i.notationMapper.notationToExternal(new jt(e.name)),this.cubie.scale.setScalar(.99),this.cubie.add(n)}},de=class{constructor(e){c(this,"axis");c(this,"order");const t=e.coordinates;this.axis=new R(t[0],t[1],t[2]),this.order=e.order}},pe=.71,B=.5,A,lt,At,xt,me=(xt=class extends Dt{constructor(t,i,s,r=!1,n=!1,o=1,a=1,l={}){super();W(this,lt);c(this,"stickers");c(this,"axesInfo");c(this,"stickerTargets",[]);c(this,"controlTargets",[]);c(this,"movingObj");c(this,"filler");c(this,"foundationBound");c(this,"fixedGeo");c(this,"lastPos");c(this,"lastMoveTransformation");c(this,"hintMaterial");c(this,"stickerMaterial");c(this,"materialArray1");c(this,"materialArray2");c(this,"textured",!1);c(this,"showHintStickers",!1);c(this,"showFoundations",!1);c(this,"hintMaterialDisposable");c(this,"stickerMaterialDisposable");W(this,A,!1);c(this,"isPG3DForTwisty3DPuzzleWrapper");if(this.scheduleRenderCallback=t,this.kpuzzle=i,this.stickerDat=s,this.faceletScale=a,this.params=l,s.stickers.length===0)throw Error("Reuse of stickerdat from pg; please don't do that.");this.hintMaterial=new x({vertexColors:!0,transparent:!0,opacity:.5}),this.hintMaterialDisposable=!0,this.stickerMaterial=Y,this.stickerMaterialDisposable=!1,this.axesInfo={};const f=this.stickerDat.axis;for(const d of f)this.axesInfo[d.quantumMove.family]=new de(d);const k=this.stickerDat.stickers;this.stickers={},this.materialArray1=new Array(8),this.materialArray2=new Array(8),this.showFoundation(r),r=!0;let E=0;const v=3;for(const d of k){const S=d.coords.length/3;E+=v*(S-2)}const g=new Tt(E,s.textureMapper),p=0,C=[];let b=0;for(const d of s.faces)C.push(le(d.coords)),b+=oe(d.coords);const T=a!=="auto"?a*a:pe;let G=0;for(const d of k)d.isDup||G++;const L=Math.sqrt(b/G)*(1-Math.sqrt(T))/2;for(const d of k){const S=d.orbit,w=d.ord,P=d.ori;this.stickers[S]||(this.stickers[S]=[]),this.stickers[S][P]||(this.stickers[S][P]=[]);const St={};l.stickeringMask&&(St.stickeringMask=wt(l.stickeringMask,S,w,P,!1));const Ut=new ue(g,d,L,St);this.stickers[S][P][w]=Ut}this.showHintStickers=n,n=!0;for(const d of k){const S=d.orbit,w=d.ord,P=d.ori;this.stickers[S][P][w].addHint(g,d,n,o,L,C[d.face])}this.foundationBound=g.ipos;for(const d of k){const S=d.orbit,w=d.ord,P=d.ori;r&&this.stickers[S][P][w].addFoundation(g,d,p)}const F=new kt;g.setAttributes(F),g.makeGroups(F);const O=new tt(F,this.materialArray1);O.scale.set(B,B,B),this.add(O);const D=new tt(F,this.materialArray2);D.scale.set(B,B,B),this.add(D);const y=this.stickerDat.faces;this.movingObj=D,this.fixedGeo=F,this.filler=g;for(const d of y){const S=new fe(d,s.textureMapper,this.stickerDat);S.cubie.scale.set(B,B,B),this.add(S.cubie),this.controlTargets.push(S.cubie.children[0])}g.saveOriginalColors(),s.stickers=[],this.updateMaterialArrays()}dispose(){this.fixedGeo&&this.fixedGeo.dispose(),this.stickerMaterialDisposable&&(this.stickerMaterial.dispose(),this.stickerMaterial=Y,this.stickerMaterialDisposable=!1),this.hintMaterialDisposable&&(this.hintMaterial.dispose(),this.hintMaterial=Y,this.hintMaterialDisposable=!1)}experimentalGetStickerTargets(){return this.stickerTargets}experimentalGetControlTargets(){return this.controlTargets}getClosestMoveToAxis(t,i){let s=null,r=0,n=a=>a;switch(i.depth){case"secondSlice":{n=a=>a.modified({innerLayer:2});break}case"rotation":{n=a=>a.modified({family:`${a.family}v`});break}}for(const a of this.stickerDat.axis){const l=t.dot(new R(...a.coordinates));if(l>r){const f=this.stickerDat.notationMapper.notationToExternal(n(a.quantumMove));if(!f)continue;V(this,lt,At).call(this,f)&&(r=l,s=f)}}if(!s)return null;i.invert&&(s=s.invert());const o=this.kpuzzle.moveToTransformation(s).repetitionOrder();return{move:s,order:o}}setStickeringMask(t){if(this.params.stickeringMask=t,t.specialBehaviour!=="picture")for(const i of this.kpuzzle.definition.orbits){const{numPieces:s,numOrientations:r}=i;for(let n=0;n<s;n++)for(let o=0;o<r;o++){const a=wt(t,i.orbitName,n,o,!1),l=this.stickers[i.orbitName][o][n];this.textured&&this.hintMaterialDisposable&&a==="invisible"||l.setStickeringMask(this.filler,a)}}_(this,A,!0),this.lastPos&&this.onPositionChange(this.lastPos)}onPositionChange(t){const i=t.pattern.experimentalToTransformation();if(!i)throw new Error("indistinguishable pieces are not supported by PG3D yet");const s=new H;this.movingObj.rotation.copy(s);let r=0;const n=this.filler,o=n.ind;if(!this.lastPos||q(this,A)||!this.lastPos.pattern.experimentalToTransformation().isIdentical(i)){for(const l in this.stickers){const f=this.stickers[l],k=i.transformationData[l],E=f.length;if(E===1){const v=f[0];for(let g=0;g<v.length;g++){const p=k.permutation[g];this.textured?r+=v[g].setTexture(n,v[p]):r+=v[g].setColor(n,v[p])}}else for(let v=0;v<E;v++){const g=f[v];for(let p=0;p<g.length;p++){const C=(v+E-k.orientationDelta[p])%E,b=k.permutation[p];this.textured?r+=g[p].setTexture(n,f[C][b]):r+=g[p].setColor(n,f[C][b])}}}this.lastPos=t}let a=0;for(const l of t.movesInProgress){const f=l.move,k=this.stickerDat.unswizzle(f);if(!k)return;const E=f;let v;try{v=this.kpuzzle.moveToTransformation(E.modified({amount:1}))}catch(b){const T=this.stickerDat.notationMapper.notationToInternal(E);if(T){const G=this.stickerDat.notationMapper.notationToExternal(T.modified({amount:1}));G&&(v=this.kpuzzle.moveToTransformation(G))}if(!v)throw console.log(b),b}const g=this.axesInfo[k.family],p=g.axis,C=-this.ease(l.fraction)*l.direction*k.amount*U/g.order;if(this.movingObj.rotateOnAxis(p,C),this.lastMoveTransformation!==v){for(const b in this.stickers){const T=this.stickers[b],G=T.length,L=v.transformationData[b];for(let F=0;F<G;F++){const O=T[F];for(let D=0;D<O.length;D++){const y=O[D],d=L.permutation[D];let S=0;if((d!==D||L.orientationDelta[D]!==0)&&(S=1),S!==y.twistVal){if(S){for(let w=y.stickerStart;w<y.stickerEnd;w++)o[w]|=1;for(let w=y.hintStart;w<y.hintEnd;w++)o[w]|=1;for(let w=y.foundationStart;w<y.foundationEnd;w++)o[w]|=1}else{for(let w=y.stickerStart;w<y.stickerEnd;w++)o[w]&=-2;for(let w=y.hintStart;w<y.hintEnd;w++)o[w]&=-2;for(let w=y.foundationStart;w<y.foundationEnd;w++)o[w]&=-2}y.twistVal=S,a++}}}}this.lastMoveTransformation=v}}(q(this,A)||a)&&this.filler.makeGroups(this.fixedGeo),(q(this,A)||r)&&(this.textured&&(this.fixedGeo.getAttribute("uv").addUpdateRange(0,6*this.foundationBound),this.fixedGeo.getAttribute("uv").needsUpdate=!0),(q(this,A)||!this.textured)&&(this.fixedGeo.getAttribute("color").addUpdateRange(0,9*this.foundationBound),this.fixedGeo.getAttribute("color").needsUpdate=!0)),this.scheduleRenderCallback(),_(this,A,!1)}ease(t){return Ft(t)}showHintFacelets(t){this.showHintStickers=t}updateMaterialArrays(){for(let t=0;t<8;t++)this.materialArray1[t]=I,this.materialArray2[t]=I;this.materialArray1[0]=this.stickerMaterial,this.materialArray2[1]=this.stickerMaterial,this.showHintStickers?(this.materialArray1[2]=this.hintMaterial,this.materialArray2[3]=this.hintMaterial):(this.materialArray1[2]=I,this.materialArray2[3]=I),this.showFoundations?(this.materialArray1[6]=Mt,this.materialArray2[7]=Mt):(this.materialArray1[6]=I,this.materialArray2[7]=I)}showFoundation(t){this.showFoundations=t}setHintStickerOpacity(t){this.hintMaterialDisposable&&(this.hintMaterial.dispose(),this.hintMaterialDisposable=!1),t===0?this.hintMaterial=I:t===1?this.hintMaterial=this.stickerMaterial:(this.hintMaterial=new x({vertexColors:!0,transparent:!0,opacity:t}),this.hintMaterialDisposable=!0)}experimentalUpdateOptions(t){t.hintFacelets!==void 0&&this.showHintFacelets(t.hintFacelets!=="none"),t.showFoundation!==void 0&&this.showFoundation(t.showFoundation),t.hintStickerOpacity!==void 0&&this.setHintStickerOpacity(t.hintStickerOpacity),_(this,A,!0),this.lastPos&&this.onPositionChange(this.lastPos),typeof t.faceletScale<"u"&&t.faceletScale!==this.faceletScale&&console.warn("Dynamic facelet scale is not yet supported for PG3D. For now, re-create the TwistyPlayer to change the facelet scale."),this.updateMaterialArrays(),this.scheduleRenderCallback()}adduvs(){const t=this.filler;if(t.uvs)return;this.filler.uvs=new Float32Array(12*t.sz);for(const s in this.stickers){const r=this.stickers[s],n=r.length;for(let o=0;o<n;o++){const a=r[o];for(const l of a)l.addUVs(this.filler)}}t.uvs.copyWithin(6*t.sz,0,6*t.sz);const i=t.uvs.subarray(0,6*t.sz);this.fixedGeo.setAttribute("uv",new $(i,2,!0))}experimentalUpdateTexture(t,i,s){i||(t=!1),t&&!this.filler.uvs&&this.adduvs(),this.textured=t,this.stickerMaterialDisposable&&(this.stickerMaterial.dispose(),this.stickerMaterialDisposable=!1),t?(this.stickerMaterial=new x({map:i,side:nt,transparent:!1}),this.stickerMaterialDisposable=!0):this.stickerMaterial=Y,this.hintMaterialDisposable&&(this.hintMaterial.dispose(),this.hintMaterialDisposable=!1),t?(this.hintMaterial=new x({map:s,side:nt,transparent:!0}),this.hintMaterialDisposable=!0):this.hintMaterial=Y,t&&this.showHintFacelets(s!==null),this.updateMaterialArrays(),_(this,A,!0),this.lastPos&&this.onPositionChange(this.lastPos),this.scheduleRenderCallback()}},A=new WeakMap,lt=new WeakSet,At=function(t){try{return this.kpuzzle.moveToTransformation(t),!0}catch{return!1}},xt),we=class{constructor(){c(this,"renderTargets",new Set);c(this,"twisty3Ds",new Set);c(this,"threeJSScene",(async()=>new(await Pt).Scene)())}addRenderTarget(e){this.renderTargets.add(e)}scheduleRender(){for(const e of this.renderTargets)e.scheduleRender()}async addTwisty3DPuzzle(e){this.twisty3Ds.add(e),(await this.threeJSScene).add(e)}async removeTwisty3DPuzzle(e){this.twisty3Ds.delete(e),(await this.threeJSScene).remove(e)}async clearPuzzles(){for(const e of this.twisty3Ds)(await this.threeJSScene).remove(e);this.twisty3Ds.clear()}};async function ve(e,t){return new re(await It.kpuzzle(),e,t)}async function ye(e,t,i,s,r){return new me(e,await t.kpuzzle(),(await t.pg()).get3d({darkIgnoredOrbits:r}),!0,i==="floating",void 0,s)}export{re as Cube3D,me as PG3D,Ee as T3I,we as Twisty3DScene,ve as cube3DShim,ye as pg3dShim};
